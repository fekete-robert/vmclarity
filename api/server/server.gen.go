// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.15.0 DO NOT EDIT.
package server

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	. "github.com/openclarity/vmclarity/api/models"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get asset scan estimations according to the given filters
	// (GET /assetScanEstimations)
	GetAssetScanEstimations(ctx echo.Context, params GetAssetScanEstimationsParams) error
	// Create an asset scan estimation for a specified asset
	// (POST /assetScanEstimations)
	PostAssetScanEstimations(ctx echo.Context) error
	// Delete an asset scan estimation.
	// (DELETE /assetScanEstimations/{assetScanEstimationID})
	DeleteAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID) error
	// Get an asset scan estimation.
	// (GET /assetScanEstimations/{assetScanEstimationID})
	GetAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID, params GetAssetScanEstimationsAssetScanEstimationIDParams) error
	// Patch an asset scan estimation
	// (PATCH /assetScanEstimations/{assetScanEstimationID})
	PatchAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID, params PatchAssetScanEstimationsAssetScanEstimationIDParams) error
	// Update an asset scan estimation.
	// (PUT /assetScanEstimations/{assetScanEstimationID})
	PutAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID, params PutAssetScanEstimationsAssetScanEstimationIDParams) error
	// Get asset scans according to the given filters
	// (GET /assetScans)
	GetAssetScans(ctx echo.Context, params GetAssetScansParams) error
	// Create an asset scan for a specified asset
	// (POST /assetScans)
	PostAssetScans(ctx echo.Context) error
	// Get an asset scan.
	// (GET /assetScans/{assetScanID})
	GetAssetScansAssetScanID(ctx echo.Context, assetScanID AssetScanID, params GetAssetScansAssetScanIDParams) error
	// Patch an asset scan
	// (PATCH /assetScans/{assetScanID})
	PatchAssetScansAssetScanID(ctx echo.Context, assetScanID AssetScanID, params PatchAssetScansAssetScanIDParams) error
	// Update an asset scan.
	// (PUT /assetScans/{assetScanID})
	PutAssetScansAssetScanID(ctx echo.Context, assetScanID AssetScanID, params PutAssetScansAssetScanIDParams) error
	// Get assets
	// (GET /assets)
	GetAssets(ctx echo.Context, params GetAssetsParams) error
	// Create asset
	// (POST /assets)
	PostAssets(ctx echo.Context) error
	// Delete asset.
	// (DELETE /assets/{assetID})
	DeleteAssetsAssetID(ctx echo.Context, assetID AssetID) error
	// Get asset.
	// (GET /assets/{assetID})
	GetAssetsAssetID(ctx echo.Context, assetID AssetID, params GetAssetsAssetIDParams) error
	// Update asset.
	// (PATCH /assets/{assetID})
	PatchAssetsAssetID(ctx echo.Context, assetID AssetID, params PatchAssetsAssetIDParams) error
	// Update asset.
	// (PUT /assets/{assetID})
	PutAssetsAssetID(ctx echo.Context, assetID AssetID, params PutAssetsAssetIDParams) error
	// Auth callback.
	// (GET /callback)
	Callback(ctx echo.Context) error
	// Get all findings.
	// (GET /findings)
	GetFindings(ctx echo.Context, params GetFindingsParams) error
	// Create a finding
	// (POST /findings)
	PostFindings(ctx echo.Context) error
	// Delete a finding.
	// (DELETE /findings/{findingID})
	DeleteFindingsFindingID(ctx echo.Context, findingID FindingID) error
	// Get the details for a finding.
	// (GET /findings/{findingID})
	GetFindingsFindingID(ctx echo.Context, findingID FindingID, params GetFindingsFindingIDParams) error
	// Patch a finding.
	// (PATCH /findings/{findingID})
	PatchFindingsFindingID(ctx echo.Context, findingID FindingID) error
	// Update a finding.
	// (PUT /findings/{findingID})
	PutFindingsFindingID(ctx echo.Context, findingID FindingID) error
	// Login user.
	// (GET /login)
	Login(ctx echo.Context) error
	// Logout user.
	// (GET /logout)
	Logout(ctx echo.Context) error
	// Get this OpenAPI spec
	// (GET /openapi.json)
	GetOpenAPISpec(ctx echo.Context) error
	// Get personal user data.
	// (GET /profile)
	GetCurrentUser(ctx echo.Context) error
	// Get all scan configs.
	// (GET /scanConfigs)
	GetScanConfigs(ctx echo.Context, params GetScanConfigsParams) error
	// Create a scan config
	// (POST /scanConfigs)
	PostScanConfigs(ctx echo.Context) error
	// Delete a scan config.
	// (DELETE /scanConfigs/{scanConfigID})
	DeleteScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID) error
	// Get the details for a scan config.
	// (GET /scanConfigs/{scanConfigID})
	GetScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID, params GetScanConfigsScanConfigIDParams) error
	// Patch a scan config.
	// (PATCH /scanConfigs/{scanConfigID})
	PatchScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID, params PatchScanConfigsScanConfigIDParams) error
	// Update a scan config.
	// (PUT /scanConfigs/{scanConfigID})
	PutScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID, params PutScanConfigsScanConfigIDParams) error
	// Get all scan estimations. Each scan estimation contains details about a multi-asset scan estimation.
	// (GET /scanEstimations)
	GetScanEstimations(ctx echo.Context, params GetScanEstimationsParams) error
	// Create a multi-asset scan estimation
	// (POST /scanEstimations)
	PostScanEstimations(ctx echo.Context) error
	// Delete a scan estimation.
	// (DELETE /scanEstimations/{scanEstimationID})
	DeleteScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID) error
	// Get the details for a given multi-asset scan estimation.
	// (GET /scanEstimations/{scanEstimationID})
	GetScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID, params GetScanEstimationsScanEstimationIDParams) error
	// Patch a scan estimation.
	// (PATCH /scanEstimations/{scanEstimationID})
	PatchScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID, params PatchScanEstimationsScanEstimationIDParams) error
	// Update a scan estimation.
	// (PUT /scanEstimations/{scanEstimationID})
	PutScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID, params PutScanEstimationsScanEstimationIDParams) error
	// Get all scans. Each scan contains details about a multi-asset scheduled scan.
	// (GET /scans)
	GetScans(ctx echo.Context, params GetScansParams) error
	// Create a multi-asset scheduled scan
	// (POST /scans)
	PostScans(ctx echo.Context) error
	// Delete a scan.
	// (DELETE /scans/{scanID})
	DeleteScansScanID(ctx echo.Context, scanID ScanID) error
	// Get the details for a given multi-asset scheduled scan.
	// (GET /scans/{scanID})
	GetScansScanID(ctx echo.Context, scanID ScanID, params GetScansScanIDParams) error
	// Patch a scan.
	// (PATCH /scans/{scanID})
	PatchScansScanID(ctx echo.Context, scanID ScanID, params PatchScansScanIDParams) error
	// Update a scan.
	// (PUT /scans/{scanID})
	PutScansScanID(ctx echo.Context, scanID ScanID, params PutScansScanIDParams) error
	// Delete a user auth credentials.
	// (DELETE /user-auth/{userID})
	DeleteUserAuthUserID(ctx echo.Context, userID UserID) error
	// Get user auth data.
	// (GET /user-auth/{userID})
	GetUserAuthUserID(ctx echo.Context, userID UserID) error
	// Create user auth credentials.
	// (POST /user-auth/{userID})
	PostUserAuthUserID(ctx echo.Context, userID UserID, params PostUserAuthUserIDParams) error
	// Get all users.
	// (GET /users)
	GetUsers(ctx echo.Context, params GetUsersParams) error
	// Create a user.
	// (POST /users)
	PostUser(ctx echo.Context) error
	// Delete a user.
	// (DELETE /users/{userID})
	DeleteUsersUserID(ctx echo.Context, userID UserID) error
	// Get the details for a user.
	// (GET /users/{userID})
	GetUsersUserID(ctx echo.Context, userID UserID) error
	// Patch a user.
	// (PATCH /users/{userID})
	PatchUsersUserID(ctx echo.Context, userID UserID) error
	// Update a user.
	// (PUT /users/{userID})
	PutUsersUserID(ctx echo.Context, userID UserID) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAssetScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScanEstimations(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:list:assetScanEstimation"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScanEstimationsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScanEstimations(ctx, params)
	return err
}

// PostAssetScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) PostAssetScanEstimations(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:create:assetScanEstimation"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAssetScanEstimations(ctx)
	return err
}

// DeleteAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetScanEstimationID", runtime.ParamLocationPath, ctx.Param("assetScanEstimationID"), &assetScanEstimationID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:delete:assetScanEstimation"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID)
	return err
}

// GetAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetScanEstimationID", runtime.ParamLocationPath, ctx.Param("assetScanEstimationID"), &assetScanEstimationID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:get:assetScanEstimation"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScanEstimationsAssetScanEstimationIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID, params)
	return err
}

// PatchAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetScanEstimationID", runtime.ParamLocationPath, ctx.Param("assetScanEstimationID"), &assetScanEstimationID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:assetScanEstimation"})

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchAssetScanEstimationsAssetScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID, params)
	return err
}

// PutAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PutAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetScanEstimationID", runtime.ParamLocationPath, ctx.Param("assetScanEstimationID"), &assetScanEstimationID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:assetScanEstimation"})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAssetScanEstimationsAssetScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID, params)
	return err
}

// GetAssetScans converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScans(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:list:assetScan"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScansParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScans(ctx, params)
	return err
}

// PostAssetScans converts echo context to params.
func (w *ServerInterfaceWrapper) PostAssetScans(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:create:assetScan"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAssetScans(ctx)
	return err
}

// GetAssetScansAssetScanID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScansAssetScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanID" -------------
	var assetScanID AssetScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetScanID", runtime.ParamLocationPath, ctx.Param("assetScanID"), &assetScanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:get:assetScan"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScansAssetScanIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScansAssetScanID(ctx, assetScanID, params)
	return err
}

// PatchAssetScansAssetScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAssetScansAssetScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanID" -------------
	var assetScanID AssetScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetScanID", runtime.ParamLocationPath, ctx.Param("assetScanID"), &assetScanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:assetScan"})

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchAssetScansAssetScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchAssetScansAssetScanID(ctx, assetScanID, params)
	return err
}

// PutAssetScansAssetScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PutAssetScansAssetScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanID" -------------
	var assetScanID AssetScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetScanID", runtime.ParamLocationPath, ctx.Param("assetScanID"), &assetScanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:assetScan"})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAssetScansAssetScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutAssetScansAssetScanID(ctx, assetScanID, params)
	return err
}

// GetAssets converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssets(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:list:asset"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssets(ctx, params)
	return err
}

// PostAssets converts echo context to params.
func (w *ServerInterfaceWrapper) PostAssets(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:create:asset"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAssets(ctx)
	return err
}

// DeleteAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetID", runtime.ParamLocationPath, ctx.Param("assetID"), &assetID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:delete:asset"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAssetsAssetID(ctx, assetID)
	return err
}

// GetAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetID", runtime.ParamLocationPath, ctx.Param("assetID"), &assetID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:get:asset"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetsAssetIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetsAssetID(ctx, assetID, params)
	return err
}

// PatchAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetID", runtime.ParamLocationPath, ctx.Param("assetID"), &assetID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:asset"})

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchAssetsAssetIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchAssetsAssetID(ctx, assetID, params)
	return err
}

// PutAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) PutAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetID", runtime.ParamLocationPath, ctx.Param("assetID"), &assetID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:asset"})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAssetsAssetIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutAssetsAssetID(ctx, assetID, params)
	return err
}

// Callback converts echo context to params.
func (w *ServerInterfaceWrapper) Callback(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Callback(ctx)
	return err
}

// GetFindings converts echo context to params.
func (w *ServerInterfaceWrapper) GetFindings(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:list:finding"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFindingsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFindings(ctx, params)
	return err
}

// PostFindings converts echo context to params.
func (w *ServerInterfaceWrapper) PostFindings(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:create:finding"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFindings(ctx)
	return err
}

// DeleteFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithLocation("simple", false, "findingID", runtime.ParamLocationPath, ctx.Param("findingID"), &findingID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:delete:finding"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteFindingsFindingID(ctx, findingID)
	return err
}

// GetFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) GetFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithLocation("simple", false, "findingID", runtime.ParamLocationPath, ctx.Param("findingID"), &findingID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:get:finding"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFindingsFindingIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFindingsFindingID(ctx, findingID, params)
	return err
}

// PatchFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithLocation("simple", false, "findingID", runtime.ParamLocationPath, ctx.Param("findingID"), &findingID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:finding"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchFindingsFindingID(ctx, findingID)
	return err
}

// PutFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) PutFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithLocation("simple", false, "findingID", runtime.ParamLocationPath, ctx.Param("findingID"), &findingID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:finding"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutFindingsFindingID(ctx, findingID)
	return err
}

// Login converts echo context to params.
func (w *ServerInterfaceWrapper) Login(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Login(ctx)
	return err
}

// Logout converts echo context to params.
func (w *ServerInterfaceWrapper) Logout(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Logout(ctx)
	return err
}

// GetOpenAPISpec converts echo context to params.
func (w *ServerInterfaceWrapper) GetOpenAPISpec(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOpenAPISpec(ctx)
	return err
}

// GetCurrentUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetCurrentUser(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCurrentUser(ctx)
	return err
}

// GetScanConfigs converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanConfigs(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:list:scanConfig"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanConfigsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanConfigs(ctx, params)
	return err
}

// PostScanConfigs converts echo context to params.
func (w *ServerInterfaceWrapper) PostScanConfigs(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:update:scanConfig"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostScanConfigs(ctx)
	return err
}

// DeleteScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanConfigID", runtime.ParamLocationPath, ctx.Param("scanConfigID"), &scanConfigID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:delete:scanConfig"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteScanConfigsScanConfigID(ctx, scanConfigID)
	return err
}

// GetScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanConfigID", runtime.ParamLocationPath, ctx.Param("scanConfigID"), &scanConfigID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:get:scanConfig"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanConfigsScanConfigIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanConfigsScanConfigID(ctx, scanConfigID, params)
	return err
}

// PatchScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanConfigID", runtime.ParamLocationPath, ctx.Param("scanConfigID"), &scanConfigID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:scanConfig"})

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchScanConfigsScanConfigIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchScanConfigsScanConfigID(ctx, scanConfigID, params)
	return err
}

// PutScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) PutScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanConfigID", runtime.ParamLocationPath, ctx.Param("scanConfigID"), &scanConfigID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:scanConfig"})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutScanConfigsScanConfigIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutScanConfigsScanConfigID(ctx, scanConfigID, params)
	return err
}

// GetScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanEstimations(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:list:scanEstimation"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanEstimationsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanEstimations(ctx, params)
	return err
}

// PostScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) PostScanEstimations(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:create:scanEstimation"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostScanEstimations(ctx)
	return err
}

// DeleteScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanEstimationID", runtime.ParamLocationPath, ctx.Param("scanEstimationID"), &scanEstimationID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:delete:scanEstimation"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteScanEstimationsScanEstimationID(ctx, scanEstimationID)
	return err
}

// GetScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanEstimationID", runtime.ParamLocationPath, ctx.Param("scanEstimationID"), &scanEstimationID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:get:scanEstimation"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanEstimationsScanEstimationIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanEstimationsScanEstimationID(ctx, scanEstimationID, params)
	return err
}

// PatchScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanEstimationID", runtime.ParamLocationPath, ctx.Param("scanEstimationID"), &scanEstimationID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:scanEstimation"})

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchScanEstimationsScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchScanEstimationsScanEstimationID(ctx, scanEstimationID, params)
	return err
}

// PutScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PutScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanEstimationID", runtime.ParamLocationPath, ctx.Param("scanEstimationID"), &scanEstimationID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:scanEstimation"})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutScanEstimationsScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutScanEstimationsScanEstimationID(ctx, scanEstimationID, params)
	return err
}

// GetScans converts echo context to params.
func (w *ServerInterfaceWrapper) GetScans(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:list:scan"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScansParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScans(ctx, params)
	return err
}

// PostScans converts echo context to params.
func (w *ServerInterfaceWrapper) PostScans(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:create:scan"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostScans(ctx)
	return err
}

// DeleteScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanID", runtime.ParamLocationPath, ctx.Param("scanID"), &scanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:delete:scan"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteScansScanID(ctx, scanID)
	return err
}

// GetScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) GetScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanID", runtime.ParamLocationPath, ctx.Param("scanID"), &scanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:get:scan"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScansScanIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScansScanID(ctx, scanID, params)
	return err
}

// PatchScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanID", runtime.ParamLocationPath, ctx.Param("scanID"), &scanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:scan"})

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchScansScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchScansScanID(ctx, scanID, params)
	return err
}

// PutScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PutScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanID", runtime.ParamLocationPath, ctx.Param("scanID"), &scanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:scan"})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutScansScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutScansScanID(ctx, scanID, params)
	return err
}

// DeleteUserAuthUserID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteUserAuthUserID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userID" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithLocation("simple", false, "userID", runtime.ParamLocationPath, ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:delete:userAuth"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteUserAuthUserID(ctx, userID)
	return err
}

// GetUserAuthUserID converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserAuthUserID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userID" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithLocation("simple", false, "userID", runtime.ParamLocationPath, ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:list:userAuth"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUserAuthUserID(ctx, userID)
	return err
}

// PostUserAuthUserID converts echo context to params.
func (w *ServerInterfaceWrapper) PostUserAuthUserID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userID" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithLocation("simple", false, "userID", runtime.ParamLocationPath, ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:create:userAuth"})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostUserAuthUserIDParams
	// ------------- Required query parameter "credentialType" -------------

	err = runtime.BindQueryParameter("form", true, true, "credentialType", ctx.QueryParams(), &params.CredentialType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter credentialType: %s", err))
	}

	// ------------- Optional query parameter "credentialExpiry" -------------

	err = runtime.BindQueryParameter("form", true, false, "credentialExpiry", ctx.QueryParams(), &params.CredentialExpiry)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter credentialExpiry: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostUserAuthUserID(ctx, userID, params)
	return err
}

// GetUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsers(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:list:user"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUsersParams
	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUsers(ctx, params)
	return err
}

// PostUser converts echo context to params.
func (w *ServerInterfaceWrapper) PostUser(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:create:user"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostUser(ctx)
	return err
}

// DeleteUsersUserID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteUsersUserID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userID" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithLocation("simple", false, "userID", runtime.ParamLocationPath, ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:delete:user"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteUsersUserID(ctx, userID)
	return err
}

// GetUsersUserID converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsersUserID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userID" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithLocation("simple", false, "userID", runtime.ParamLocationPath, ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:get:user"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUsersUserID(ctx, userID)
	return err
}

// PatchUsersUserID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchUsersUserID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userID" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithLocation("simple", false, "userID", runtime.ParamLocationPath, ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:user"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchUsersUserID(ctx, userID)
	return err
}

// PutUsersUserID converts echo context to params.
func (w *ServerInterfaceWrapper) PutUsersUserID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userID" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithLocation("simple", false, "userID", runtime.ParamLocationPath, ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:user"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutUsersUserID(ctx, userID)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/assetScanEstimations", wrapper.GetAssetScanEstimations)
	router.POST(baseURL+"/assetScanEstimations", wrapper.PostAssetScanEstimations)
	router.DELETE(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.DeleteAssetScanEstimationsAssetScanEstimationID)
	router.GET(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.GetAssetScanEstimationsAssetScanEstimationID)
	router.PATCH(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.PatchAssetScanEstimationsAssetScanEstimationID)
	router.PUT(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.PutAssetScanEstimationsAssetScanEstimationID)
	router.GET(baseURL+"/assetScans", wrapper.GetAssetScans)
	router.POST(baseURL+"/assetScans", wrapper.PostAssetScans)
	router.GET(baseURL+"/assetScans/:assetScanID", wrapper.GetAssetScansAssetScanID)
	router.PATCH(baseURL+"/assetScans/:assetScanID", wrapper.PatchAssetScansAssetScanID)
	router.PUT(baseURL+"/assetScans/:assetScanID", wrapper.PutAssetScansAssetScanID)
	router.GET(baseURL+"/assets", wrapper.GetAssets)
	router.POST(baseURL+"/assets", wrapper.PostAssets)
	router.DELETE(baseURL+"/assets/:assetID", wrapper.DeleteAssetsAssetID)
	router.GET(baseURL+"/assets/:assetID", wrapper.GetAssetsAssetID)
	router.PATCH(baseURL+"/assets/:assetID", wrapper.PatchAssetsAssetID)
	router.PUT(baseURL+"/assets/:assetID", wrapper.PutAssetsAssetID)
	router.GET(baseURL+"/callback", wrapper.Callback)
	router.GET(baseURL+"/findings", wrapper.GetFindings)
	router.POST(baseURL+"/findings", wrapper.PostFindings)
	router.DELETE(baseURL+"/findings/:findingID", wrapper.DeleteFindingsFindingID)
	router.GET(baseURL+"/findings/:findingID", wrapper.GetFindingsFindingID)
	router.PATCH(baseURL+"/findings/:findingID", wrapper.PatchFindingsFindingID)
	router.PUT(baseURL+"/findings/:findingID", wrapper.PutFindingsFindingID)
	router.GET(baseURL+"/login", wrapper.Login)
	router.GET(baseURL+"/logout", wrapper.Logout)
	router.GET(baseURL+"/openapi.json", wrapper.GetOpenAPISpec)
	router.GET(baseURL+"/profile", wrapper.GetCurrentUser)
	router.GET(baseURL+"/scanConfigs", wrapper.GetScanConfigs)
	router.POST(baseURL+"/scanConfigs", wrapper.PostScanConfigs)
	router.DELETE(baseURL+"/scanConfigs/:scanConfigID", wrapper.DeleteScanConfigsScanConfigID)
	router.GET(baseURL+"/scanConfigs/:scanConfigID", wrapper.GetScanConfigsScanConfigID)
	router.PATCH(baseURL+"/scanConfigs/:scanConfigID", wrapper.PatchScanConfigsScanConfigID)
	router.PUT(baseURL+"/scanConfigs/:scanConfigID", wrapper.PutScanConfigsScanConfigID)
	router.GET(baseURL+"/scanEstimations", wrapper.GetScanEstimations)
	router.POST(baseURL+"/scanEstimations", wrapper.PostScanEstimations)
	router.DELETE(baseURL+"/scanEstimations/:scanEstimationID", wrapper.DeleteScanEstimationsScanEstimationID)
	router.GET(baseURL+"/scanEstimations/:scanEstimationID", wrapper.GetScanEstimationsScanEstimationID)
	router.PATCH(baseURL+"/scanEstimations/:scanEstimationID", wrapper.PatchScanEstimationsScanEstimationID)
	router.PUT(baseURL+"/scanEstimations/:scanEstimationID", wrapper.PutScanEstimationsScanEstimationID)
	router.GET(baseURL+"/scans", wrapper.GetScans)
	router.POST(baseURL+"/scans", wrapper.PostScans)
	router.DELETE(baseURL+"/scans/:scanID", wrapper.DeleteScansScanID)
	router.GET(baseURL+"/scans/:scanID", wrapper.GetScansScanID)
	router.PATCH(baseURL+"/scans/:scanID", wrapper.PatchScansScanID)
	router.PUT(baseURL+"/scans/:scanID", wrapper.PutScansScanID)
	router.DELETE(baseURL+"/user-auth/:userID", wrapper.DeleteUserAuthUserID)
	router.GET(baseURL+"/user-auth/:userID", wrapper.GetUserAuthUserID)
	router.POST(baseURL+"/user-auth/:userID", wrapper.PostUserAuthUserID)
	router.GET(baseURL+"/users", wrapper.GetUsers)
	router.POST(baseURL+"/users", wrapper.PostUser)
	router.DELETE(baseURL+"/users/:userID", wrapper.DeleteUsersUserID)
	router.GET(baseURL+"/users/:userID", wrapper.GetUsersUserID)
	router.PATCH(baseURL+"/users/:userID", wrapper.PatchUsersUserID)
	router.PUT(baseURL+"/users/:userID", wrapper.PutUsersUserID)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"jdXkm68h367yWeFQrdEntmbqXaaz7r40fGkPoFItlNSIH226QS8bITowXGjXYND6EFBVAzYgQNuns104",
	"cftw3RrxnIPx0vbqmm07SKG7wv8WPMI6mOh5sKGj4HhOwVFCeo6C4yg4DkVwlACkLqhRxhA9gRmfn30R",
	"f7byTD4wRMXgPsgKnUWL6mdr8sKMTuzX15eXklpevRQbkrP1jrlaXkLdsSOWmT3zOWPFqoQURYhwDGNW",
	"6509J5Fu8fKxGCI7HD9qp5svAUbf1gtnqth1fRe5Dip8pg1vNngKCnxYpqhbjcunFFMnZvz6WclqIMwk",
	"10M2ClhUK2uxUsmYOUq+HRC/xh195K+xR4/c66bfa0+FPsgCa50KdTpdkcc225amez0qEUvtOyqR29BC",
	"gAXbs4l2fdThS62hjjokYVtHHfuUOWVx8/edipuy/7IjgeM96FAZazpKl46eA9uORXaIZxr7MqVrzehG",
	"q5kduMn8jVrLM+RXMdVTh3yn604Wnm2396mxtk9cBvXTyuIwDOVvwUbWgJeL6g1S3kVj+ZHyIyNszgi7",
	"sB1L7uuREw+CE3PouZPx+PXr/w8AAP//EibrLJJAAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
