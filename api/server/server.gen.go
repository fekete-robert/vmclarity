// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.15.0 DO NOT EDIT.
package server

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	. "github.com/openclarity/vmclarity/api/models"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get asset scan estimations according to the given filters
	// (GET /assetScanEstimations)
	GetAssetScanEstimations(ctx echo.Context, params GetAssetScanEstimationsParams) error
	// Create an asset scan estimation for a specified asset
	// (POST /assetScanEstimations)
	PostAssetScanEstimations(ctx echo.Context) error
	// Delete an asset scan estimation.
	// (DELETE /assetScanEstimations/{assetScanEstimationID})
	DeleteAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID) error
	// Get an asset scan estimation.
	// (GET /assetScanEstimations/{assetScanEstimationID})
	GetAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID, params GetAssetScanEstimationsAssetScanEstimationIDParams) error
	// Patch an asset scan estimation
	// (PATCH /assetScanEstimations/{assetScanEstimationID})
	PatchAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID, params PatchAssetScanEstimationsAssetScanEstimationIDParams) error
	// Update an asset scan estimation.
	// (PUT /assetScanEstimations/{assetScanEstimationID})
	PutAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID, params PutAssetScanEstimationsAssetScanEstimationIDParams) error
	// Get asset scans according to the given filters
	// (GET /assetScans)
	GetAssetScans(ctx echo.Context, params GetAssetScansParams) error
	// Create an asset scan for a specified asset
	// (POST /assetScans)
	PostAssetScans(ctx echo.Context) error
	// Get an asset scan.
	// (GET /assetScans/{assetScanID})
	GetAssetScansAssetScanID(ctx echo.Context, assetScanID AssetScanID, params GetAssetScansAssetScanIDParams) error
	// Patch an asset scan
	// (PATCH /assetScans/{assetScanID})
	PatchAssetScansAssetScanID(ctx echo.Context, assetScanID AssetScanID, params PatchAssetScansAssetScanIDParams) error
	// Update an asset scan.
	// (PUT /assetScans/{assetScanID})
	PutAssetScansAssetScanID(ctx echo.Context, assetScanID AssetScanID, params PutAssetScansAssetScanIDParams) error
	// Get assets
	// (GET /assets)
	GetAssets(ctx echo.Context, params GetAssetsParams) error
	// Create asset
	// (POST /assets)
	PostAssets(ctx echo.Context) error
	// Delete asset.
	// (DELETE /assets/{assetID})
	DeleteAssetsAssetID(ctx echo.Context, assetID AssetID) error
	// Get asset.
	// (GET /assets/{assetID})
	GetAssetsAssetID(ctx echo.Context, assetID AssetID, params GetAssetsAssetIDParams) error
	// Update asset.
	// (PATCH /assets/{assetID})
	PatchAssetsAssetID(ctx echo.Context, assetID AssetID, params PatchAssetsAssetIDParams) error
	// Update asset.
	// (PUT /assets/{assetID})
	PutAssetsAssetID(ctx echo.Context, assetID AssetID, params PutAssetsAssetIDParams) error
	// Get all findings.
	// (GET /findings)
	GetFindings(ctx echo.Context, params GetFindingsParams) error
	// Create a finding
	// (POST /findings)
	PostFindings(ctx echo.Context) error
	// Delete a finding.
	// (DELETE /findings/{findingID})
	DeleteFindingsFindingID(ctx echo.Context, findingID FindingID) error
	// Get the details for a finding.
	// (GET /findings/{findingID})
	GetFindingsFindingID(ctx echo.Context, findingID FindingID, params GetFindingsFindingIDParams) error
	// Patch a finding.
	// (PATCH /findings/{findingID})
	PatchFindingsFindingID(ctx echo.Context, findingID FindingID) error
	// Update a finding.
	// (PUT /findings/{findingID})
	PutFindingsFindingID(ctx echo.Context, findingID FindingID) error
	// Get personal user data.
	// (GET /me)
	GetCurrentUser(ctx echo.Context) error
	// Get this OpenAPI spec
	// (GET /openapi.json)
	GetOpenAPISpec(ctx echo.Context) error
	// Get all scan configs.
	// (GET /scanConfigs)
	GetScanConfigs(ctx echo.Context, params GetScanConfigsParams) error
	// Create a scan config
	// (POST /scanConfigs)
	PostScanConfigs(ctx echo.Context) error
	// Delete a scan config.
	// (DELETE /scanConfigs/{scanConfigID})
	DeleteScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID) error
	// Get the details for a scan config.
	// (GET /scanConfigs/{scanConfigID})
	GetScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID, params GetScanConfigsScanConfigIDParams) error
	// Patch a scan config.
	// (PATCH /scanConfigs/{scanConfigID})
	PatchScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID, params PatchScanConfigsScanConfigIDParams) error
	// Update a scan config.
	// (PUT /scanConfigs/{scanConfigID})
	PutScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID, params PutScanConfigsScanConfigIDParams) error
	// Get all scan estimations. Each scan estimation contains details about a multi-asset scan estimation.
	// (GET /scanEstimations)
	GetScanEstimations(ctx echo.Context, params GetScanEstimationsParams) error
	// Create a multi-asset scan estimation
	// (POST /scanEstimations)
	PostScanEstimations(ctx echo.Context) error
	// Delete a scan estimation.
	// (DELETE /scanEstimations/{scanEstimationID})
	DeleteScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID) error
	// Get the details for a given multi-asset scan estimation.
	// (GET /scanEstimations/{scanEstimationID})
	GetScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID, params GetScanEstimationsScanEstimationIDParams) error
	// Patch a scan estimation.
	// (PATCH /scanEstimations/{scanEstimationID})
	PatchScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID, params PatchScanEstimationsScanEstimationIDParams) error
	// Update a scan estimation.
	// (PUT /scanEstimations/{scanEstimationID})
	PutScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID, params PutScanEstimationsScanEstimationIDParams) error
	// Get all scans. Each scan contains details about a multi-asset scheduled scan.
	// (GET /scans)
	GetScans(ctx echo.Context, params GetScansParams) error
	// Create a multi-asset scheduled scan
	// (POST /scans)
	PostScans(ctx echo.Context) error
	// Delete a scan.
	// (DELETE /scans/{scanID})
	DeleteScansScanID(ctx echo.Context, scanID ScanID) error
	// Get the details for a given multi-asset scheduled scan.
	// (GET /scans/{scanID})
	GetScansScanID(ctx echo.Context, scanID ScanID, params GetScansScanIDParams) error
	// Patch a scan.
	// (PATCH /scans/{scanID})
	PatchScansScanID(ctx echo.Context, scanID ScanID, params PatchScansScanIDParams) error
	// Update a scan.
	// (PUT /scans/{scanID})
	PutScansScanID(ctx echo.Context, scanID ScanID, params PutScansScanIDParams) error
	// Delete a user auth credentials.
	// (DELETE /user-auth/{userID})
	DeleteUserAuthUserID(ctx echo.Context, userID UserID) error
	// Get user auth data.
	// (GET /user-auth/{userID})
	GetUserAuthUserID(ctx echo.Context, userID UserID) error
	// Create user auth credentials.
	// (POST /user-auth/{userID})
	PostUserAuthUserID(ctx echo.Context, userID UserID, params PostUserAuthUserIDParams) error
	// Delete a user.
	// (DELETE /user/{userID})
	DeleteUsersUserID(ctx echo.Context, userID UserID) error
	// Get the details for a user.
	// (GET /user/{userID})
	GetUsersUserID(ctx echo.Context, userID UserID) error
	// Patch a user.
	// (PATCH /user/{userID})
	PatchUsersUserID(ctx echo.Context, userID UserID) error
	// Update a user.
	// (PUT /user/{userID})
	PutUsersUserID(ctx echo.Context, userID UserID) error
	// Get all users.
	// (GET /users)
	GetUsers(ctx echo.Context, params GetUsersParams) error
	// Create a user.
	// (POST /users)
	PostUser(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAssetScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScanEstimations(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:list:assetScanEstimation"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScanEstimationsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScanEstimations(ctx, params)
	return err
}

// PostAssetScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) PostAssetScanEstimations(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:create:assetScanEstimation"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAssetScanEstimations(ctx)
	return err
}

// DeleteAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetScanEstimationID", runtime.ParamLocationPath, ctx.Param("assetScanEstimationID"), &assetScanEstimationID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:delete:assetScanEstimation"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID)
	return err
}

// GetAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetScanEstimationID", runtime.ParamLocationPath, ctx.Param("assetScanEstimationID"), &assetScanEstimationID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:get:assetScanEstimation"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScanEstimationsAssetScanEstimationIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID, params)
	return err
}

// PatchAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetScanEstimationID", runtime.ParamLocationPath, ctx.Param("assetScanEstimationID"), &assetScanEstimationID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:assetScanEstimation"})

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchAssetScanEstimationsAssetScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID, params)
	return err
}

// PutAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PutAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetScanEstimationID", runtime.ParamLocationPath, ctx.Param("assetScanEstimationID"), &assetScanEstimationID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:assetScanEstimation"})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAssetScanEstimationsAssetScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID, params)
	return err
}

// GetAssetScans converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScans(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:list:assetScan"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScansParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScans(ctx, params)
	return err
}

// PostAssetScans converts echo context to params.
func (w *ServerInterfaceWrapper) PostAssetScans(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:create:assetScan"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAssetScans(ctx)
	return err
}

// GetAssetScansAssetScanID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScansAssetScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanID" -------------
	var assetScanID AssetScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetScanID", runtime.ParamLocationPath, ctx.Param("assetScanID"), &assetScanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:get:assetScan"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScansAssetScanIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScansAssetScanID(ctx, assetScanID, params)
	return err
}

// PatchAssetScansAssetScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAssetScansAssetScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanID" -------------
	var assetScanID AssetScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetScanID", runtime.ParamLocationPath, ctx.Param("assetScanID"), &assetScanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:assetScan"})

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchAssetScansAssetScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchAssetScansAssetScanID(ctx, assetScanID, params)
	return err
}

// PutAssetScansAssetScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PutAssetScansAssetScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanID" -------------
	var assetScanID AssetScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetScanID", runtime.ParamLocationPath, ctx.Param("assetScanID"), &assetScanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:assetScan"})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAssetScansAssetScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutAssetScansAssetScanID(ctx, assetScanID, params)
	return err
}

// GetAssets converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssets(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:list:asset"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssets(ctx, params)
	return err
}

// PostAssets converts echo context to params.
func (w *ServerInterfaceWrapper) PostAssets(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:create:asset"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAssets(ctx)
	return err
}

// DeleteAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetID", runtime.ParamLocationPath, ctx.Param("assetID"), &assetID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:delete:asset"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAssetsAssetID(ctx, assetID)
	return err
}

// GetAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetID", runtime.ParamLocationPath, ctx.Param("assetID"), &assetID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:get:asset"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetsAssetIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetsAssetID(ctx, assetID, params)
	return err
}

// PatchAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetID", runtime.ParamLocationPath, ctx.Param("assetID"), &assetID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:asset"})

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchAssetsAssetIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchAssetsAssetID(ctx, assetID, params)
	return err
}

// PutAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) PutAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetID", runtime.ParamLocationPath, ctx.Param("assetID"), &assetID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:asset"})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAssetsAssetIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutAssetsAssetID(ctx, assetID, params)
	return err
}

// GetFindings converts echo context to params.
func (w *ServerInterfaceWrapper) GetFindings(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:list:finding"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFindingsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFindings(ctx, params)
	return err
}

// PostFindings converts echo context to params.
func (w *ServerInterfaceWrapper) PostFindings(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:create:finding"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFindings(ctx)
	return err
}

// DeleteFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithLocation("simple", false, "findingID", runtime.ParamLocationPath, ctx.Param("findingID"), &findingID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:delete:finding"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteFindingsFindingID(ctx, findingID)
	return err
}

// GetFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) GetFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithLocation("simple", false, "findingID", runtime.ParamLocationPath, ctx.Param("findingID"), &findingID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:get:finding"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFindingsFindingIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFindingsFindingID(ctx, findingID, params)
	return err
}

// PatchFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithLocation("simple", false, "findingID", runtime.ParamLocationPath, ctx.Param("findingID"), &findingID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:finding"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchFindingsFindingID(ctx, findingID)
	return err
}

// PutFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) PutFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithLocation("simple", false, "findingID", runtime.ParamLocationPath, ctx.Param("findingID"), &findingID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:finding"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutFindingsFindingID(ctx, findingID)
	return err
}

// GetCurrentUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetCurrentUser(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCurrentUser(ctx)
	return err
}

// GetOpenAPISpec converts echo context to params.
func (w *ServerInterfaceWrapper) GetOpenAPISpec(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOpenAPISpec(ctx)
	return err
}

// GetScanConfigs converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanConfigs(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:list:scanConfig"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanConfigsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanConfigs(ctx, params)
	return err
}

// PostScanConfigs converts echo context to params.
func (w *ServerInterfaceWrapper) PostScanConfigs(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:update:scanConfig"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostScanConfigs(ctx)
	return err
}

// DeleteScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanConfigID", runtime.ParamLocationPath, ctx.Param("scanConfigID"), &scanConfigID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:delete:scanConfig"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteScanConfigsScanConfigID(ctx, scanConfigID)
	return err
}

// GetScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanConfigID", runtime.ParamLocationPath, ctx.Param("scanConfigID"), &scanConfigID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:get:scanConfig"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanConfigsScanConfigIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanConfigsScanConfigID(ctx, scanConfigID, params)
	return err
}

// PatchScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanConfigID", runtime.ParamLocationPath, ctx.Param("scanConfigID"), &scanConfigID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:scanConfig"})

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchScanConfigsScanConfigIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchScanConfigsScanConfigID(ctx, scanConfigID, params)
	return err
}

// PutScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) PutScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanConfigID", runtime.ParamLocationPath, ctx.Param("scanConfigID"), &scanConfigID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:scanConfig"})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutScanConfigsScanConfigIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutScanConfigsScanConfigID(ctx, scanConfigID, params)
	return err
}

// GetScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanEstimations(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:list:scanEstimation"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanEstimationsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanEstimations(ctx, params)
	return err
}

// PostScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) PostScanEstimations(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:create:scanEstimation"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostScanEstimations(ctx)
	return err
}

// DeleteScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanEstimationID", runtime.ParamLocationPath, ctx.Param("scanEstimationID"), &scanEstimationID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:delete:scanEstimation"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteScanEstimationsScanEstimationID(ctx, scanEstimationID)
	return err
}

// GetScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanEstimationID", runtime.ParamLocationPath, ctx.Param("scanEstimationID"), &scanEstimationID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:get:scanEstimation"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanEstimationsScanEstimationIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanEstimationsScanEstimationID(ctx, scanEstimationID, params)
	return err
}

// PatchScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanEstimationID", runtime.ParamLocationPath, ctx.Param("scanEstimationID"), &scanEstimationID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:scanEstimation"})

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchScanEstimationsScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchScanEstimationsScanEstimationID(ctx, scanEstimationID, params)
	return err
}

// PutScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PutScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanEstimationID", runtime.ParamLocationPath, ctx.Param("scanEstimationID"), &scanEstimationID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:scanEstimation"})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutScanEstimationsScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutScanEstimationsScanEstimationID(ctx, scanEstimationID, params)
	return err
}

// GetScans converts echo context to params.
func (w *ServerInterfaceWrapper) GetScans(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:list:scan"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScansParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScans(ctx, params)
	return err
}

// PostScans converts echo context to params.
func (w *ServerInterfaceWrapper) PostScans(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:create:scan"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostScans(ctx)
	return err
}

// DeleteScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanID", runtime.ParamLocationPath, ctx.Param("scanID"), &scanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:delete:scan"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteScansScanID(ctx, scanID)
	return err
}

// GetScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) GetScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanID", runtime.ParamLocationPath, ctx.Param("scanID"), &scanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:get:scan"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScansScanIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScansScanID(ctx, scanID, params)
	return err
}

// PatchScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanID", runtime.ParamLocationPath, ctx.Param("scanID"), &scanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:scan"})

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchScansScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchScansScanID(ctx, scanID, params)
	return err
}

// PutScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PutScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanID", runtime.ParamLocationPath, ctx.Param("scanID"), &scanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:scan"})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutScansScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutScansScanID(ctx, scanID, params)
	return err
}

// DeleteUserAuthUserID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteUserAuthUserID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userID" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithLocation("simple", false, "userID", runtime.ParamLocationPath, ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:delete:userAuth"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteUserAuthUserID(ctx, userID)
	return err
}

// GetUserAuthUserID converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserAuthUserID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userID" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithLocation("simple", false, "userID", runtime.ParamLocationPath, ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:list:userAuth"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUserAuthUserID(ctx, userID)
	return err
}

// PostUserAuthUserID converts echo context to params.
func (w *ServerInterfaceWrapper) PostUserAuthUserID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userID" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithLocation("simple", false, "userID", runtime.ParamLocationPath, ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:create:userAuth"})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostUserAuthUserIDParams
	// ------------- Required query parameter "credentialType" -------------

	err = runtime.BindQueryParameter("form", true, true, "credentialType", ctx.QueryParams(), &params.CredentialType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter credentialType: %s", err))
	}

	// ------------- Optional query parameter "credentialExpiry" -------------

	err = runtime.BindQueryParameter("form", true, false, "credentialExpiry", ctx.QueryParams(), &params.CredentialExpiry)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter credentialExpiry: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostUserAuthUserID(ctx, userID, params)
	return err
}

// DeleteUsersUserID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteUsersUserID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userID" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithLocation("simple", false, "userID", runtime.ParamLocationPath, ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:delete:user"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteUsersUserID(ctx, userID)
	return err
}

// GetUsersUserID converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsersUserID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userID" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithLocation("simple", false, "userID", runtime.ParamLocationPath, ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:get:user"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUsersUserID(ctx, userID)
	return err
}

// PatchUsersUserID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchUsersUserID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userID" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithLocation("simple", false, "userID", runtime.ParamLocationPath, ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:user"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchUsersUserID(ctx, userID)
	return err
}

// PutUsersUserID converts echo context to params.
func (w *ServerInterfaceWrapper) PutUsersUserID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userID" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithLocation("simple", false, "userID", runtime.ParamLocationPath, ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(AuthTokenScopes, []string{"api:update:user"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutUsersUserID(ctx, userID)
	return err
}

// GetUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsers(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:list:user"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUsersParams
	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUsers(ctx, params)
	return err
}

// PostUser converts echo context to params.
func (w *ServerInterfaceWrapper) PostUser(ctx echo.Context) error {
	var err error

	ctx.Set(AuthTokenScopes, []string{"api:create:user"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostUser(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/assetScanEstimations", wrapper.GetAssetScanEstimations)
	router.POST(baseURL+"/assetScanEstimations", wrapper.PostAssetScanEstimations)
	router.DELETE(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.DeleteAssetScanEstimationsAssetScanEstimationID)
	router.GET(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.GetAssetScanEstimationsAssetScanEstimationID)
	router.PATCH(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.PatchAssetScanEstimationsAssetScanEstimationID)
	router.PUT(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.PutAssetScanEstimationsAssetScanEstimationID)
	router.GET(baseURL+"/assetScans", wrapper.GetAssetScans)
	router.POST(baseURL+"/assetScans", wrapper.PostAssetScans)
	router.GET(baseURL+"/assetScans/:assetScanID", wrapper.GetAssetScansAssetScanID)
	router.PATCH(baseURL+"/assetScans/:assetScanID", wrapper.PatchAssetScansAssetScanID)
	router.PUT(baseURL+"/assetScans/:assetScanID", wrapper.PutAssetScansAssetScanID)
	router.GET(baseURL+"/assets", wrapper.GetAssets)
	router.POST(baseURL+"/assets", wrapper.PostAssets)
	router.DELETE(baseURL+"/assets/:assetID", wrapper.DeleteAssetsAssetID)
	router.GET(baseURL+"/assets/:assetID", wrapper.GetAssetsAssetID)
	router.PATCH(baseURL+"/assets/:assetID", wrapper.PatchAssetsAssetID)
	router.PUT(baseURL+"/assets/:assetID", wrapper.PutAssetsAssetID)
	router.GET(baseURL+"/findings", wrapper.GetFindings)
	router.POST(baseURL+"/findings", wrapper.PostFindings)
	router.DELETE(baseURL+"/findings/:findingID", wrapper.DeleteFindingsFindingID)
	router.GET(baseURL+"/findings/:findingID", wrapper.GetFindingsFindingID)
	router.PATCH(baseURL+"/findings/:findingID", wrapper.PatchFindingsFindingID)
	router.PUT(baseURL+"/findings/:findingID", wrapper.PutFindingsFindingID)
	router.GET(baseURL+"/me", wrapper.GetCurrentUser)
	router.GET(baseURL+"/openapi.json", wrapper.GetOpenAPISpec)
	router.GET(baseURL+"/scanConfigs", wrapper.GetScanConfigs)
	router.POST(baseURL+"/scanConfigs", wrapper.PostScanConfigs)
	router.DELETE(baseURL+"/scanConfigs/:scanConfigID", wrapper.DeleteScanConfigsScanConfigID)
	router.GET(baseURL+"/scanConfigs/:scanConfigID", wrapper.GetScanConfigsScanConfigID)
	router.PATCH(baseURL+"/scanConfigs/:scanConfigID", wrapper.PatchScanConfigsScanConfigID)
	router.PUT(baseURL+"/scanConfigs/:scanConfigID", wrapper.PutScanConfigsScanConfigID)
	router.GET(baseURL+"/scanEstimations", wrapper.GetScanEstimations)
	router.POST(baseURL+"/scanEstimations", wrapper.PostScanEstimations)
	router.DELETE(baseURL+"/scanEstimations/:scanEstimationID", wrapper.DeleteScanEstimationsScanEstimationID)
	router.GET(baseURL+"/scanEstimations/:scanEstimationID", wrapper.GetScanEstimationsScanEstimationID)
	router.PATCH(baseURL+"/scanEstimations/:scanEstimationID", wrapper.PatchScanEstimationsScanEstimationID)
	router.PUT(baseURL+"/scanEstimations/:scanEstimationID", wrapper.PutScanEstimationsScanEstimationID)
	router.GET(baseURL+"/scans", wrapper.GetScans)
	router.POST(baseURL+"/scans", wrapper.PostScans)
	router.DELETE(baseURL+"/scans/:scanID", wrapper.DeleteScansScanID)
	router.GET(baseURL+"/scans/:scanID", wrapper.GetScansScanID)
	router.PATCH(baseURL+"/scans/:scanID", wrapper.PatchScansScanID)
	router.PUT(baseURL+"/scans/:scanID", wrapper.PutScansScanID)
	router.DELETE(baseURL+"/user-auth/:userID", wrapper.DeleteUserAuthUserID)
	router.GET(baseURL+"/user-auth/:userID", wrapper.GetUserAuthUserID)
	router.POST(baseURL+"/user-auth/:userID", wrapper.PostUserAuthUserID)
	router.DELETE(baseURL+"/user/:userID", wrapper.DeleteUsersUserID)
	router.GET(baseURL+"/user/:userID", wrapper.GetUsersUserID)
	router.PATCH(baseURL+"/user/:userID", wrapper.PatchUsersUserID)
	router.PUT(baseURL+"/user/:userID", wrapper.PutUsersUserID)
	router.GET(baseURL+"/users", wrapper.GetUsers)
	router.POST(baseURL+"/users", wrapper.PostUser)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"BAF3PQEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
