// Copyright Â© 2022 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package util

import (
	"github.com/openclarity/vmclarity/shared/pkg/families/malware/clam/constants"
	"strconv"
	"strings"

	log "github.com/sirupsen/logrus"

	"github.com/openclarity/vmclarity/shared/pkg/families/malware/common"
)

func ParseMalwareScanOutput(clamOutput string) ([]common.DetectedMalware, *common.ScanSummary) {
	log.Infof("clam output: %s", clamOutput)
	lines := strings.Split(clamOutput, "\n")

	malwareInfoList := []common.DetectedMalware{}
	for _, line := range lines {
		if strings.Contains(line, constants.ScanSummaryText) {
			break
		}

		// Check if the line ends with "FOUND" to identify malware detections
		if !strings.Contains(line, constants.MalwareDetectedIndication) {
			continue
		}

		words := strings.Fields(line)

		// If the line has less than 3 words in it, it can't be a malware detection, so it's skipped
		if len(words) < constants.DetectedMalwareLineWordCount {
			log.Debugf("omitting invalid clam line: %s", words)
			continue
		}

		detectedMalware := extractMalwareInfo(words)

		malwareInfoList = append(malwareInfoList, *detectedMalware)
	}

	summary := parseScanSummary(clamOutput)

	return malwareInfoList, summary
}

func parseScanSummary(clamSummary string) *common.ScanSummary {
	scanSummary := &common.ScanSummary{}
	if clamSummary == "" {
		return scanSummary
	}

	lines := strings.Split(clamSummary, "\n")
	for i := len(lines) - 1; i >= 0; i-- {
		line := lines[i]
		if strings.Contains(line, constants.ScanSummaryText) {
			break
		}
		fields := strings.SplitN(line, ":", 2) // Split the field by the second colon
		if len(fields) != 2 {
			continue
		}
		field := strings.TrimSpace(fields[0])
		value := strings.TrimSpace(fields[1])
		switch field {
		case "Known viruses":
			scanSummary.KnownViruses, _ = strconv.Atoi(value)
		case "Engine version":
			scanSummary.EngineVersion = value
		case "Scanned directories":
			scanSummary.ScannedDirectories, _ = strconv.Atoi(value)
		case "Scanned files":
			scanSummary.ScannedFiles, _ = strconv.Atoi(value)
		case "Infected files":
			scanSummary.InfectedFiles, _ = strconv.Atoi(value)
		case "Data scanned":
			scanSummary.DataScanned = value
		case "Data read":
			scanSummary.DataRead = value
		case "Time":
			scanSummary.TimeTaken = value
		default:
			continue
		}
	}
	return scanSummary
}

func extractMalwareInfo(words []string) *common.DetectedMalware {
	if len(words) == 0 {
		return nil
	}
	// Extract the file path from the words
	filePath := strings.TrimSuffix(words[constants.DetectedMalwarePathPosition], ":")

	// Extract the malware name and type from the words
	malwareDesc := words[constants.DetectedMalwareDescriptionPosition]
	splitMalwareDesc := strings.SplitN(malwareDesc, ".", constants.MaxMalwareDescriptionSections)

	malwareTypeIndex := 0
	if len(splitMalwareDesc) == constants.MaxMalwareDescriptionSections {
		malwareTypeIndex = constants.LongMalwareTypePosition
	}

	malwareTypeStr := strings.ToUpper(splitMalwareDesc[malwareTypeIndex])

	malwareName := splitMalwareDesc[len(splitMalwareDesc)-1]

	return &common.DetectedMalware{
		MalwareName: malwareName,
		MalwareType: malwareTypeStr,
		Path:        filePath,
	}
}
