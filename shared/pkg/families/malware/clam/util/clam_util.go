// Copyright Â© 2022 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package util

import (
	"github.com/openclarity/vmclarity/shared/pkg/families/malware/clam/constants"
	"strings"

	log "github.com/sirupsen/logrus"

	"github.com/openclarity/vmclarity/shared/pkg/families/malware/common"
)

func ParseMalwareScanOutput(clamOutput string) *[]common.DetectedMalware {
	lines := strings.Split(clamOutput, "\n")

	malwareInfoList := []common.DetectedMalware{}

	for _, line := range lines {
		// Check if the line ends with "FOUND" to identify malware detections
		if !strings.Contains(line, constants.MalwareDetectedIndication) {
			continue
		}

		words := strings.Fields(line)

		// If the line has less than 3 words in it, it can't be a malware detection, so it's skipped
		if len(words) < constants.DetectedMalwareLineWordCount {
			log.Debugf("omitting invalid clam line: %s", words)
			continue
		}

		detectedMalware := extractMalwareInfo(words)

		malwareInfoList = append(malwareInfoList, detectedMalware)
	}
	return &malwareInfoList
}

func extractMalwareInfo(words []string) common.DetectedMalware {
	// Extract the file path from the words
	filePath := strings.TrimSuffix(words[constants.DetectedMalwarePathPosition], ":")

	// Extract the malware name and type from the words
	malwareDesc := words[constants.DetectedMalwareDescriptionPosition]
	splitMalwareDesc := strings.SplitN(malwareDesc, ".", constants.MaxMalwareDescriptionSections)

	malwareTypeIndex := 0
	if len(splitMalwareDesc) == constants.MaxMalwareDescriptionSections {
		malwareTypeIndex = constants.LongMalwareTypePosition
	}

	malwareTypeStr := strings.ToUpper(splitMalwareDesc[malwareTypeIndex])

	malwareName := splitMalwareDesc[len(splitMalwareDesc)-1]

	return common.DetectedMalware{
		MalwareName: malwareName,
		MalwareType: malwareTypeStr,
		Path:        filePath,
	}
}
